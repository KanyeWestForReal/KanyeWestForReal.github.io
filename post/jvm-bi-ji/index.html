<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>JVM 笔记 | Grinofith&#39;s Blog</title>
<link rel="shortcut icon" href="https://kanyewestforreal.github.io//favicon.ico?v=1765275803375">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://kanyewestforreal.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="JVM 笔记 | Grinofith&#39;s Blog - Atom Feed" href="https://kanyewestforreal.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="JVM内存模型
以HotSpot JVM举例。
1.7

1.8

注意
HotSpot JVM内存结构主要分为：堆内存（线程共享）、方法区（线程共享）、栈+程序计数器（线程私有）。
概念上：
堆内存：存放对象实例和数组。
方法区：存储类元..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <!-- <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script> -->
    <script src="//cdn.jsdelivr.net/npm/leancloud-storage@4.13.2/dist/av-min.js"></script>
    <script src="/media/js/read_mark.js"></script>
    <script src="/media/js/highlight/highlight.min.js"></script>
    <script src="/media/js/sroll_markdown_titile_list.js"></script>
    <link rel="stylesheet" type="text/css" href="/media/js/highlight/styles/atom-one-dark.css">
    <script>hljs.highlightAll();</script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://kanyewestforreal.github.io/">
  <img class="avatar" src="https://kanyewestforreal.github.io//images/avatar.png?v=1765275803375" alt="">
  </a>
  <h1 class="site-title">
    Grinofith&#39;s Blog
  </h1>
  <p class="site-description">
    The key is seriously reflecting.
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              JVM 笔记
            </h2>
            <div class="post-info">
              <span>
                2025-12-08
              </span>
              <span class="post-views">
                  <span >阅读量：</span>
                  <span id="dynamic-views-counter"></span>
              </span>
              <span>
                43 min read
              </span>
              
            </div>
            
              <img class="post-feature-image" src="https://kanyewestforreal.github.io//post-images/jvm-bi-ji.jpg" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <h1 id="jvm内存模型">JVM内存模型</h1>
<p><strong>以HotSpot JVM举例</strong>。</p>
<p>1.7</p>
<figure data-type="image" tabindex="1"><img src="https://kanyewestforreal.github.io//post-images/JVMMM_JDK1.7_wm.png" alt="java-runtime-data-areas-jdk1.8" loading="lazy"></figure>
<p>1.8</p>
<figure data-type="image" tabindex="2"><img src="https://kanyewestforreal.github.io//post-images/JVMMM_JDK1.8_wm.png" alt="java-runtime-data-areas-jdk1.8" loading="lazy"></figure>
<h2 id="注意">注意</h2>
<p>HotSpot JVM内存结构主要分为：<strong>堆内存（线程共享）、方法区（线程共享）、栈+程序计数器（线程私有）。</strong></p>
<p><strong>概念上</strong>：</p>
<p><strong>堆内存：存放对象实例和数组。</strong></p>
<p><strong>方法区：存储类元数据、运行时常量、字符串常量、静态变量。</strong></p>
<p>**方法区是JVM规定的一个概念，JVM必须要存在这么一个区域，但是实现可以由不同的方式实现（元空间、永久代 或者其他名字）。**甚至不同的实现，方法区保存的数据也不同。</p>
<p>比如JDK 1.7实现的<strong>永久代</strong>物理内存被设计在<code>Java Heap</code>中，但是实际上不属于堆。以及<strong>字符串常量池</strong>不在永久代，而在<code>Java Heap</code>中。</p>
<p>比如JDK 1.8实现的<strong>元空间</strong>物理内存不放在堆中，而放在本地内存<code>Native Memory</code>。</p>
<p>比如Android ART虚拟机实现的方法区放在堆中。</p>
<p><strong>static静态变量本身（其作为类的一部分）的存储位置</strong>，分两种情况：</p>
<ul>
<li>对于基本类型（<code>int</code>、<code>boolean</code>等）的静态变量，其<strong>值直接存储在元空间</strong>的类定义中。</li>
<li>对于非基本类型的静态变量，<strong>引用（指针）存储在元空间</strong>，而<strong>被引用的对象实例存储在堆</strong>中。</li>
</ul>
<h2 id="堆heap">堆（Heap）</h2>
<p>被所有线程共享。对象实例、数组存储区域（GC主战场）。</p>
<p>大多数对象是朝生夕死，只有少数对象会存活很久，因此将堆分代可以大幅提高 GC 效率。</p>
<p>堆可以进一步细分为：</p>
<h3 id="年轻代young-generation">年轻代（Young Generation）</h3>
<p>年轻代用于新生对象的分配与回收，它又细分为 3 个区；</p>
<p>Eden区：相对较小，当Eden区满时，会触发一次Minor GC（新生代垃圾回收，频率高）。</p>
<p>S0（Survivor 0）和S1（Survivor 1）：两个 Survivor 区轮流作为“to/from”。from 区是上次GC的存活对象，to 区存本次 GC 后的<code>Eden+Survivor</code>活对象，每次 Minor GC 后，两块 Survivor 互换身份，确保始终有一块空白用于复制。（碎片化小，GC+复制算法不能在同一区域执行）</p>
<h3 id="老年代old-generation">老年代（Old Generation）</h3>
<p>经历过一次或多次Minor GC仍存活的对象会被移动到老年代。老年代的GC叫Major GC（也称为Full GC）发生的频率相对较低，执行时间通常比Minor GC长。老年代的空间通常比新生代大，以存储更多的长期存活对象。</p>
<p>大对象通常会直接分配到老年代，因为通常需要连续的内存空间，老年代比较大，防止分配失败。</p>
<p>如果在堆中没有内存完成实例分配，并且堆也无法扩展时会抛出 OutOfMemoryError 异常。</p>
<h3 id="对象如何晋升到-old-区">对象如何晋升到 Old 区？</h3>
<p>晋升路径：</p>
<ol>
<li><strong>年龄超过阈值（默认 15）</strong></li>
<li>Survivor 放不下 → 直接晋升</li>
<li>动态年龄判断（Survivor 同龄对象占比超过 50%）</li>
</ol>
<h2 id="方法区method-area">方法区（Method Area）</h2>
<p>存储类元数据、运行时常量、字符串常量（JDK7及以后被移至堆）、静态变量（但被引用对象在堆）。方法区可以选择不实现垃圾收集。</p>
<h2 id="虚拟机栈jvm-stack">虚拟机栈（JVM Stack）</h2>
<p><strong>每个线程都有自己独立的</strong> Java 虚拟机栈，生命周期与线程相同。<strong>每个Java方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息</strong>。可能会抛出 StackOverflowError 和 OutOfMemoryError 异常。</p>
<h2 id="本地方法栈native-method-stack">本地方法栈（Native Method Stack）</h2>
<p><strong>每个线程都有自己独立的</strong>本地方法栈，生命周期与线程相同。与 Java 虚拟机栈作用类似。Native方法执行时也会创建栈帧，同样可能出现 StackOverflowError 和 OutOfMemoryError 两种错误。</p>
<h2 id="程序计数器pc-register">程序计数器（PC Register）</h2>
<p>可以看作是当前线程<strong>所执行的字节码的行号指示器</strong>，用于存储当前线程正在执行的 <strong>Java 方法</strong>的 JVM 指令地址。如果线程执行的是 <strong>Native 方法，计数器值为 null</strong>。是唯一一个在 Java 虚拟机规范中<strong>没有规定 OutOfMemoryError 情况</strong>的区域，生命周期与线程相同。</p>
<h2 id="直接内存-direct-memory">直接内存 Direct Memory</h2>
<p>可以通过 NIO、Unsafe 类操作，可以显著提高 I/O 性能。直接内存是对<code>Native Memory for JVM</code>的再分配，使用受到本机总内存的限制，若分配不当，可能导致 OutOfMemoryError 异常。</p>
<h2 id="stack-和-heap-的区别">Stack 和 Heap 的区别？</h2>
<h3 id="存放内容不同">存放内容不同</h3>
<ul>
<li><strong>栈</strong>：方法调用的栈帧、局部变量（基础类型）、操作数栈</li>
<li><strong>堆</strong>：所有对象实例、数组</li>
</ul>
<h3 id="管理方式不同">管理方式不同</h3>
<ul>
<li><strong>栈</strong>：由线程自动分配和销毁（线程私有）</li>
<li><strong>堆</strong>：由 JVM 的垃圾回收器（GC）管理（线程共享）</li>
</ul>
<h3 id="生命周期不同">生命周期不同</h3>
<ul>
<li><strong>栈</strong>：随线程创建，线程结束时销毁</li>
<li><strong>堆</strong>：JVM 运行过程中一直存在</li>
</ul>
<h3 id="访问速度不同">访问速度不同</h3>
<ul>
<li><strong>栈</strong>：速度快（编译期确定结构）</li>
<li><strong>堆</strong>：速度慢（需要 GC、对象查找）</li>
</ul>
<h3 id="线程共享性不同">线程共享性不同</h3>
<ul>
<li><strong>栈</strong>：线程私有</li>
<li><strong>堆</strong>：线程共享</li>
</ul>
<h3 id="注意-2">注意</h3>
<p>如果局部变量是基本类型（如int, double等）则在线程栈的局部变量表上；方法返回基本类型，是值传递，不会分配堆内存，值直接写入返回值寄存器（或返回值槽）</p>
<p>如果局部变量是非基础类型，**栈上只存引用；对象始终在堆上。**因为 Java 的对象生命周期不由方法结束来决定，可能方法结束后对象还在使用（比如返回值、闭包、线程间共享），因此对象必须放在 Heap（共享、可 GC）。</p>
<h2 id="当程序中通过对象或类直接调用某个方法时jvm执行了哪些操作">当程序中通过对象或类直接调用某个方法时，JVM执行了哪些操作？</h2>
<h3 id="预备知识">预备知识</h3>
<p>Java文件被编译成Class文件后，变量和方法的调用都作为符号引用保存在Class文件中的常量池中。</p>
<pre><code class="language-java">// 源代码
public class Demo {
    public int add(int a, int b) {
        return a + b;
    }
    
    public static void main(String[] args) {
        Demo demo = new Demo();
        int result = demo.add(1, 2);
    }
}

// main方法的字节码（简化版）
0: new           #2      // #2 = class com/example/Demo
3: dup
4: invokespecial #3      // #3 = Method &quot;&lt;init&gt;&quot;:()V
7: astore_1
8: aload_1
9: iconst_1
10: iconst_2
11: invokevirtual #4     // #4 = Method add:(II)I ⬅️ 方法调用点
</code></pre>
<p><strong>编译期只是产生符号引用（Symbolic Reference）</strong>，编译器不会决定最终调用哪个类、哪个类的方法，真正运行时先写入<code>MetaSpace</code>常量池，执行某条字节码命令时才会解析<code>Symbolic Reference</code>确定类/方法。</p>
<p>所有方法的调用在Class文件里面都只是符号引用，非虚方法的调用在类加载时会被直接确定（一次性且最终的），虚方法的调用在字节码执行（运行期）期间才能确定，这是Java强大的动态扩展能力的基础。</p>
<p>非虚方法：</p>
<p><strong>static 方法</strong> 不能覆写</p>
<p><strong>private 方法</strong> 不能子类可见</p>
<p><strong>final 方法</strong> 明确禁止覆盖</p>
<p><strong>构造方法</strong> 只能属于本类</p>
<p><strong>super 调用</strong> 语义明确定向父类</p>
<h3 id="invoke的解析">invoke的解析</h3>
<p><code>invokevirtual #4</code> 指向常量池的<strong>符号引用</strong>（声明类 + 方法名 + 描述符）。</p>
<pre><code class="language-java">// 字节码中的方法调用引用
invokevirtual #4  // 常量池索引4

// 常量池项结构
ConstantPoolEntry {
    tag: CONSTANT_Methodref (10)
    class_index: 指向类名
    name_and_type_index: 指向方法名和描述符
}
</code></pre>
<p>JVM 会<strong>解析</strong>该符号引用，</p>
<p>1.通过<code>CONSTANT_Methodref</code> 确定是方法的符号引用</p>
<p>2.解析 <code>class_index</code> → 如果类没被加载，就加载类。</p>
<pre><code class="language-java">// 类加载时构建方法表
class ClassLoader {
  void prepare_methods(Klass* klass) {
    for (Method* method : klass-&gt;methods()) {
      if (method-&gt;is_static() || 
          method-&gt;is_private() || 
          method-&gt;is_constructor()) {
        // 非虚方法，不放入vtable
        method-&gt;set_vtable_index(-1);
      } else if (method-&gt;is_final()) {
        // final方法：放入vtable，但不会被子类覆盖
        method-&gt;set_vtable_index(calculate_index());
      }
    }
    
    // 构建vtable（只包含虚方法）
    build_virtual_method_table(klass);
  }
}
</code></pre>
<p>3.解析 <code>name_and_type_index</code> → 获取方法名和描述符</p>
<p>4.检查类的方法表（MethodTable / methods 数组），找到对应的方法解析，得到<code>ResolvedMethod</code>。</p>
<pre><code class="language-c++">struct ResolvedMethod {
    void* _entry_point;      // 方法入口地址
    int   _vtable_index;     // vtable索引（虚方法）
    bool  _is_virtual;       // 是否是虚方法
};
</code></pre>
<h3 id="准备执行">准备执行</h3>
<p>如果是<code>invokestatic/invokespeacil</code>，那么接下来可以直接使用刚刚获取的<code>ResolvedMethod</code>，不走虚分派。</p>
<p>如果是 <code>invokevirtual/invokeinterface</code>，那么以刚刚的<code>ResolvedMethod</code>，作为起点方法。</p>
<p>1.获得对象的引用</p>
<p>2.检查对象的实际类型</p>
<p>3.通过对象头找到实际类型的Klass指针</p>
<p>4.访问实际类型的vtable</p>
<p>5.根据“起点方法”的<code>slot index</code>（只有相同的<code>slot index</code>才能保证覆盖方法），得到实际类型对应方法在其<code>vtable</code>的偏移量。</p>
<p>6.获取实际要执行的方法入口地址</p>
<p>这就是 <strong>动态绑定</strong>。</p>
<h3 id="建立栈帧">建立栈帧</h3>
<p>方法调用过程非常简单，直接跳转到目标方法入口地址。</p>
<p>每一次方法调用都会创建一个新的栈帧，包括：</p>
<ul>
<li>局部变量表（包括 this）</li>
<li>操作数栈</li>
<li>常量池引用</li>
<li>返回地址</li>
<li>方法返回值槽</li>
</ul>
<p>栈帧入栈后，JVM 就开始按字节码解释执行。</p>
<h3 id="执行">执行</h3>
<p>执行方式可能有两种：</p>
<h4 id="解释执行interpreter">解释执行（Interpreter）</h4>
<p>逐条解释字节码。</p>
<h4 id="jit-编译成本地机器码">JIT 编译成本地机器码</h4>
<p>热点方法会被 C1/C2 编译器编译成本地代码，执行速度极快。</p>
<h3 id="结束-销毁栈帧">结束、销毁栈帧</h3>
<p>栈帧弹出、返回值写到上层栈：</p>
<ul>
<li>基本类型 → 写到返回值槽或寄存器</li>
<li>引用类型 → 返回对象引用</li>
</ul>
<p>栈帧销毁，程序回到调用方。</p>
<h3 id="总结">总结</h3>
<p>方法调用时，JVM 会前往<code>MetaSpace</code>的常量池，确认类加载，然后解析符号引用为方法的直接引用 → 准备执行，确定实际调用的方法版本（静态或动态分派） → 为方法创建栈帧 → 执行方法的字节码或 JIT 机器码 → 返回结果并销毁栈帧。</p>
<h2 id="string的奇妙机制">String的奇妙机制</h2>
<p>String 是 Java 的字符串类型（类），而“字符串”是它的实例。</p>
<h3 id="1-字面量方式">1. 字面量方式</h3>
<pre><code>String s1 = &quot;abc&quot;;
String s2 = &quot;abc&quot;;
</code></pre>
<p>查找<strong>字符串常量池（String Intern Pool）（在堆中）</strong>，是否有<code>&quot;abc&quot;</code>，</p>
<p>无：<code>&quot;abc&quot;</code> 会被放入字符串常量池</p>
<p>有：<code>s2</code> 指向常量池中的这个对象</p>
<p>特点：</p>
<ul>
<li>常量池内的字符串具有 <strong>全局共享</strong>、<strong>唯一性</strong></li>
<li>重复出现 <code>&quot;abc&quot;</code> 时不会创建新的对象</li>
</ul>
<h3 id="2-new-创建方式">2. new 创建方式</h3>
<pre><code>String s1 = new String(&quot;abc&quot;);
String s2 = new String(&quot;abc&quot;);
</code></pre>
<p>发生两件事：</p>
<ol>
<li><code>&quot;abc&quot;</code> → <strong>在常量池中创建/查找</strong></li>
<li><code>new String(&quot;abc&quot;)</code> → <strong>在堆上创建一个新的 String 对象，这个String对象指向&quot;abc&quot;</strong></li>
</ol>
<p>因此：</p>
<ul>
<li><strong>常量池有一个对象</strong></li>
<li><strong>堆中有两个的对象</strong></li>
</ul>
<p><code>s1</code> 和 <code>s2</code> 是两个引用变量，分别指向两个不同的堆对象，地址不同。但是分别指向的对象的内容相同。</p>
<pre><code class="language-java">s1 == s2  // false
s1.equals(s2) → true
</code></pre>
<h2 id="引用类型">引用类型</h2>
<p>引用类型主要分为强软弱虚四种：</p>
<ul>
<li>
<p>强引用：指的就是代码中普遍存在的赋值方式，比如<code>A a = new A()</code>这种。<strong>只要有强引用指向对象时，GC 永远不会回收它</strong>，哪怕内存不足也会抛 OutOfMemoryError 也不回收。</p>
</li>
<li>
<p>软引用：可以用SoftReference来实现，指的是那些有用但是不是必须要的对象。**系统在发生内存溢出前会对这类引用的对象进行回收。**适合用作缓存。</p>
<pre><code class="language-java">SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[1024 * 1024]);
</code></pre>
</li>
<li>
<p>弱引用：可以用WeakReference来实现，他的强度比软引用更低一点，**弱引用的对象下一次GC的时候一定会被回收，而不管内存是否足够。**被回收后，<code>get()</code>方法会返回<code>null</code>，记得做<code>check</code>。</p>
<pre><code class="language-java">WeakReference&lt;MyObject&gt; weakRef = new WeakReference&lt;&gt;(new MyObject());
</code></pre>
</li>
<li>
<p>虚引用：也被称作幻影引用，是最弱的引用关系，可以用PhantomReference来实现，其必须和ReferenceQueue一起使用，同样的当发生GC的时候，虚引用也会被回收。不能通过 <code>get()</code> 得到其引用的对象，也就是不能使用其引用的对象。主要用途是跟踪对象被 GC 回收的时机。主要用于管理堆外内存、大对象的回收时机。</p>
<pre><code class="language-java">PhantomReference&lt;MyObject&gt; phantom =
        new PhantomReference&lt;&gt;(new MyObject(), referenceQueue);
</code></pre>
</li>
</ul>
<p>为了让开发者能够控制对象的生命周期强弱，减少缓存导致的内存泄漏（<code>SoftReference</code>），避免弱引用（<code>WeakReference</code>）关联的 key 泄漏（<code>ThreadLocal</code>、<code>WeakHashMap</code>），在对象被释放时做额外清理动作（PhantomReference 用于堆外内存清理）。</p>
<h2 id="内存泄露-内存溢出的原因例子">内存泄露、内存溢出的原因/例子</h2>
<h3 id="内存泄露">内存泄露</h3>
<p><strong>程序不再需要某些对象，但仍然保持对它们的强引用，导致 GC 无法回收，内存被长期占用。</strong></p>
<p>在 JVM 中，只要对象还有“可达引用链”，GC 就不会回收它。因此，泄漏往往来自：</p>
<ul>
<li>数据结构忘记清理</li>
<li>长生命周期的对象持有短生命周期对象的引用</li>
<li>注册、回调未注销；I/O资源未关闭。</li>
<li>静态变量持有大对象</li>
<li>线程池使用<code>ThreadLocal</code>，且未手动<code>remove</code></li>
</ul>
<h3 id="内存溢出">内存溢出</h3>
<p>当 JVM 试图分配对象但找不到足够的内存空间时抛出。</p>
<h4 id="java-heap-space-oom">Java Heap Space OOM</h4>
<p>当出现<code>Java.lang.OutOfMemoryError:Java heap space</code>异常时，就是堆内存溢出了。准备分配内存给新对象，内存不够，在多次GC之后，还是无法找到一块足够大的内存容纳当前对象，就会抛出Java Heap Space OOM。</p>
<ul>
<li>数据量过大</li>
<li>无限创建对象</li>
<li>集合未限制大小</li>
<li>缓存不当</li>
<li>内存泄漏引起堆满</li>
</ul>
<h4 id="stackoverflowerror">StackOverFlowError</h4>
<p>方法递归太深：可能是参数配置错误、边界条件没有考虑、没有退出条件。</p>
<p>就会导致不断地进行压栈。类似这种情况，JVM 实际会抛出 <code>StackOverFlowError</code>，此时如果 JVM 试图去扩展栈空间的的时候失败，则会抛出 <code>StackOverFlowError</code>。</p>
<h4 id="metaspace-oom">MetaSpace OOM</h4>
<p>元空间的溢出，系统会抛出<code>Java.lang.OutOfMemoryError: Metaspace</code>。出现这个异常的问题的原因是<strong>系统的代码非常多</strong>、<strong>引用的第三方包非常多</strong>、<strong>通过动态代码生成类加载等方法</strong>，导致元空间的内存占用很大，在拓展元空间时又失败了，则会抛出<code>MetaSpace OOM</code>。</p>
<h4 id="direct-buffer-memory">Direct Buffer Memory</h4>
<p>在使用<code>ByteBuffer</code>中的<code>allocateDirect()</code>的时候，或者使用JavaNIO(像netty)的框架超出当前内存限制，会抛出<code>Java.lang.OutOfMemoryError: Direct buffer memory</code>异常。</p>
<h1 id="逃逸分析">逃逸分析</h1>
<p>HotSpot C2 编译器会对每个 <code>new</code> 进行逃逸分析，判断对象作用域，决定对象是否进入堆，或者分解对象为标量在栈/寄存器上分配内存。（在编译期就决定好了）</p>
<h2 id="什么是逃逸">什么是逃逸？</h2>
<p>对象在方法内是否“逃出当前作用域”。</p>
<h2 id="逃逸类型">逃逸类型</h2>
<h3 id="完全不逃逸noescape">完全不逃逸（NoEscape）</h3>
<p>对象只在方法内部使用</p>
<pre><code class="language-java">int f() {
    Point p = new Point(1, 2);
    //JVM 会把 p 拆成两个独立的 int（标量替换）
    //对象的所有字段都能单独分析
	//对象不会被需要“真实存在”
    //那么分配在寄存器上
    return p.x + p.y;
}

void test() {
    Foo f = new Foo();
    // this 传入可能用到完整对象结构（非标量）
    // 栈上分配
    f.bar(this); 
}
</code></pre>
<p>优化结果：</p>
<p><strong>不在堆上创建对象</strong>，直接分配在栈/寄存器上。</p>
<hr>
<h3 id="方法逃逸argescape">方法逃逸（ArgEscape）</h3>
<p>对象作为参数传递出去：</p>
<pre><code class="language-java">void foo() {
    Bar b = new Bar();
    list.add(b); // 逃逸到方法外
}
</code></pre>
<p>b 被外部存储，逃逸。需要分配到堆上。</p>
<hr>
<h3 id="全局逃逸globalescape">全局逃逸（GlobalEscape）</h3>
<p>对象变成类字段、静态字段或被返回：</p>
<pre><code class="language-java">static Foo f;
f = new Foo(); // 全局逃逸
</code></pre>
<p>一定要在堆上分配。</p>
<h2 id="逃逸优化策略">逃逸优化策略</h2>
<p>HotSpot C2 编译器可进行三种优化：</p>
<hr>
<h3 id="标量替换scalar-replacement">标量替换（Scalar Replacement）</h3>
<p>如果对象内部字段都能单独处理，则：</p>
<ul>
<li><strong>对象完全消失，不会分配内存（堆或栈均不会使用）</strong></li>
<li>“new Point()” 会被优化掉</li>
<li>字段如 <code>x</code>、<code>y</code> 会变成独立的局部变量或寄存器</li>
</ul>
<p>例如：</p>
<pre><code class="language-java">Point p = new Point(1, 2);
int r = p.x + p.y;
</code></pre>
<p>最终不会产生任何对象，也不会调用构造方法。这节省最多的 GC 压力。</p>
<hr>
<h3 id="栈上分配stack-allocation">栈上分配（Stack Allocation）</h3>
<p>如果对象<strong>不能标量化，但不会逃逸</strong>：</p>
<ul>
<li>对象分配在 <strong>栈帧</strong></li>
<li>方法结束自动回收</li>
<li>不需要 GC</li>
</ul>
<p>真实 JVM 中：<br>
HotSpot 使用 <strong>逃逸分析 + 线程栈/寄存器优化</strong>，但“纯栈上分配”不直接暴露给开发者，更多通过标量替换完成。</p>
<hr>
<h3 id="普通堆分配tlab-eden">普通堆分配（TLAB / Eden）</h3>
<p>对象逃逸，则必须进入堆，进入下面讲的堆分配策略。</p>
<h1 id="创建对象过程">创建对象过程</h1>
<p>（假定逃逸分析后，对象仍需要分配在堆上）</p>
<p>解析类符号引用 → 类加载检查 → 分配内存 → 零值初始化 → 设置对象头 → 执行构造方法</p>
<pre><code class="language-java">Foo f = new Foo();

// #3 是常量池中 Foo 的 Class 符号引用
new #3
// dup 把刚创建但未初始化的Reference，再复制一份到操作数栈顶部。
//因为接下来 invokespecial 需要Reference作为参数初始化接收对象
//而 new 本身也需要返回Reference，一份要给构造函数做参数，一份留给用户代码。
dup
// 调用 Foo类 &lt;init&gt; 构造方法。
// #4 是 Foo类构造函数 的符号引用

// JVM 解析方法符号引用
// 1.进行类加载检查
// 2.接下来虚拟机将为新生对象分配内存，对象所需的内存大小在类加载完成后便可确定
// 3.零值初始化
// 4.设置对象头
// 在上面工作都完成之后，从JVM的视角来看，一个新的对象已经产生了
// 但从Java程序的视角来看，对象创建才刚开始——构造函数还没有执行，所有的字段都还为零。
// 定位到真正的构造方法，执行构造方法，初始化字段。
invokespecial #4
//将构造完成的Reference存入局部变量表 slot 1。
astore_1
</code></pre>
<h2 id="类加载检查">类加载检查</h2>
<p>若 <code>Foo</code> 尚未加载，立即进行类加载过程。</p>
<h2 id="分配对象内存堆-heap">分配对象内存（堆 Heap）</h2>
<p>否则，根据类计算出一个对象需要的内存大小，不同的内存大小影响着JVM的分配策略：</p>
<ul>
<li>fast-path：直接分配在TLAB上 <strong>(线程本地分配缓冲区，Thread-Local Allocation Buffer)</strong></li>
<li>slow-path：可能用到锁，在 Eden 全局区上分配（超过TLAB最大容量，只能分配在堆的共享区域）</li>
</ul>
<p>分配的大小 = <strong>对象头 + 实例字段总大小（含对齐）</strong>，<strong>也就是说在堆分配对象需要的内存，需要类加载完成后进行。</strong></p>
<h3 id="指针碰撞-空闲列表-tlab">指针碰撞、空闲列表、TLAB</h3>
<p>指针碰撞和空闲列表是JVM分配内存的两种方式。</p>
<h3 id="指针碰撞">指针碰撞</h3>
<p>JVM维护一个指向当前未使用内存起始位置的指针。当需要为新对象分配内存时，JVM只需将指针向前移动与对象大小相等的距离，并将这段内存分配给对象。这种分配方式就像是一个“碰撞”过程，因此得名指针碰撞。只适用于Java堆内存连续的情况。</p>
<h3 id="空闲列表">空闲列表</h3>
<p>空闲列表适用于Java堆内存不连续的情况。在这种情况下，已使用和未使用的内存块相互交错，无法简单地通过移动指针来分配内存。因此，JVM需要维护一个空闲列表，记录哪些内存块是可用的。空闲列表通常是一个链表结构，每个节点代表一个可用的内存块。</p>
<h3 id="tlab">TLAB</h3>
<p>假定只使用移动指针：</p>
<p>线程 A 检查某一内存区域可用，准备移动指针。但在它移动之前，线程 B 也检查到这一内存区域可用，并抢先移动了指针。这时线程 A 再移动指针，就会覆盖掉线程 B 分配的内存区域。</p>
<p>TLAB 的出现就是为了解决上述并发分配的性能瓶颈（<strong>只用锁效率太低</strong>）。它的核心思想非常直观：<strong>给每个线程分配一小块专属的内存区域（缓冲区），线程优先在自己的缓冲区里分配对象。</strong></p>
<p>当然，如果 TLAB 剩余空间不足以容纳要分配的对象，或者 TLAB 完全用完，线程就需要申请一个新的 TLAB。申请新 TLAB 的过程需要同步，因为它涉及到从共享的 Eden 区获取一块新的内存。<strong>但相比于每次分配小对象都进行同步，申请 TLAB 的频率要低得多（只有当 TLAB 用完时才需要）。这大大减少了锁竞争的次数。</strong></p>
<p>如果要分配的对象太大，超过了 TLAB 的容量（甚至可能超过了单个 TLAB 的最大允许大小），那么这个对象就不会在 TLAB 中分配。JVM 则会尝试直接在 <strong>Eden 区的共享部分</strong>（如果还有空间）进行分配。这个过程可能需要加锁。</p>
<h1 id="类加载过程">类加载过程</h1>
<p>加载 → 链接（验证、准备、解析） → 初始化</p>
<p>JVM的类加载过程是懒加载的，只有使用到的时候才会加载。</p>
<h2 id="加载">加载</h2>
<p>JVM读取到对应的符号引用，查类加载器的内部哈希表是否存在对应 Klass 元数据。 否则，执行 <code>classLoader</code> 的 <code>loadClass</code>，通过类的全限定名（包名 + 类名），获取到该类的<code>.class</code>文件的<strong>二进制字节流</strong>，将二进制字节流所代表的静态存储结构，转化为方法区<code>MetaSpace</code>运行时的数据结构<code>Klass</code>，在堆中生成一个代表该类的<code>Java.lang.Class</code>对象，作为方法区<code>Klass</code>的访问入口（镜像对象）。</p>
<p><strong>类加载器的内部哈希表</strong>（如 <code>SystemDictionary</code>）：</p>
<ul>
<li>key = fully-qualified name（类的完全限定名）</li>
<li>value = Klass 对象</li>
</ul>
<p><strong>因此，如果是同一完全限定下的类，被不同类加载器加载，可以说这两个类是不同的。<code>Java</code>判断一个类相同必须是：相同的完全限定名+相同的类加载器。</strong></p>
<p>调用<code>ClassLoader</code>类的<code>loadClass</code>方法加载一个类，不算对类的主动使用，不会导致类的初始化。</p>
<h2 id="连接">连接</h2>
<p>验证、准备、解析 3 个阶段统称为连接。</p>
<h3 id="验证">验证</h3>
<p>确保<code>class</code>文件中的字节流包含的信息，符合当前虚拟机的要求，保证这个被加载的class类的正确性，不会危害到虚拟机的安全。验证阶段大致会完成以下四个阶段的检验动作：文件格式校验、元数据验证、字节码验证、符号引用验证。</p>
<h3 id="准备">准备</h3>
<p>为类中的<strong>静态字段</strong>分配内存，并设置默认的初始值，比如int类型初始值是0。</p>
<p>被final修饰的static字段不会设置，因为final在编译的时候就分配了。</p>
<h3 id="解析">解析</h3>
<p>解析 = <strong>把运行时常量池中符号引用解析为指向“真实类、字段、方法”的直接引用。</strong></p>
<p>符号引用是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用的时候可以无歧义地定位到目标即可。</p>
<p>直接引用可以是直接指向目标的指针、相对偏移量、一个能间接定位到目标的句柄（由虚拟机决定）。如果有了直接引用， 那引用的目标必定已经存在在内存中了。</p>
<p>解析阶段 <strong>不会一股脑解析全常量池</strong>。</p>
<p>那解析阶段到底做了哪些“必须要做”的解析？</p>
<p>HotSpot 主要做下面几类：</p>
<h4 id="解析类层级结构相关的符号引用">解析类层级结构相关的符号引用</h4>
<p>立即解析</p>
<p>例如：</p>
<ul>
<li>父类（super class）</li>
<li>接口（interfaces）</li>
<li>注解类</li>
<li>需要验证的方法签名、字段类型引用</li>
</ul>
<p>解析阶段会确保：</p>
<pre><code class="language-java">父类能成功加载
父类已通过验证
接口能成功加载
接口也完成验证
</code></pre>
<p>这些都属于<strong>结构性解析</strong>，不延迟。</p>
<h4 id="解析非虚方法的引用">解析“非虚方法”的引用</h4>
<p>能静态绑定的都立即解析</p>
<p>包括：</p>
<ul>
<li>private 方法</li>
<li>static 方法（invokestatic）</li>
<li>构造方法（<init>）</li>
<li>final 方法</li>
<li>super 调用方法（invokespecial）</li>
</ul>
<p>这些在类加载时即可确定，不依赖运行时对象的多态，所以 HotSpot 直接解析。</p>
<p>例如 <code>Test</code> 类中调用：</p>
<pre><code class="language-java">invokestatic #42
invokespecial #15
</code></pre>
<p><strong>解析阶段就会解析</strong>。</p>
<h4 id="解析方法句柄">解析方法句柄</h4>
<p>invokedynamic 的 bootstrap method 必须解析，<br>
因为 bootstrap 必须在链接时执行。</p>
<p>一些 MethodHandle 也需要提前检查合法性。</p>
<h4 id="对某些符号引用进行合法性验证">对某些符号引用进行“合法性验证”</h4>
<p>例如：</p>
<ul>
<li>字段签名是否存在对应类型</li>
<li>方法的参数类型是否存在</li>
<li>方法名是否与对应类匹配</li>
<li>子类是否正确实现了父接口的方法要求</li>
</ul>
<p>这些属于 <strong>semantic check（语义检查）</strong>，<br>
是“解析检查”，但不是“解析成直接引用”。</p>
<p>也就是说：</p>
<blockquote>
<p><em><em>解析阶段会验证符号引用的合法性，但不会生成 Method* 或 Field</em>。</em>*</p>
</blockquote>
<h4 id="准备-vtableitable-的结构">准备 vtable/itable 的结构</h4>
<p>HotSpot 在解析阶段会构建：</p>
<ul>
<li>vtable 大小</li>
<li>itable slot</li>
<li>方法布局、重写关系</li>
</ul>
<p>但不绑定具体 Method*</p>
<p>但不会在解析阶段解析每个虚方法引用。虚方法引用必须 Lazy Resolution。</p>
<h4 id="哪些解析被延迟lazy-resolution">哪些解析被延迟（Lazy Resolution）？</h4>
<p>下面这些全部不在解析阶段做，而是字节码第一次执行时做：</p>
<h5 id="ainvokevirtual-的方法解析虚方法">A）invokevirtual 的方法解析（虚方法）</h5>
<p>涉及运行时类型 + 动态绑定，不可能在解析阶段做完。</p>
<h5 id="binvokeinterface-的解析">B）invokeinterface 的解析</h5>
<p>需要查找接口方法在 itable 中的槽位。</p>
<h5 id="cgetfield-putfield-getstatic-putstatic">C）getfield / putfield / getstatic / putstatic</h5>
<p>字段 offset 的解析全部延迟。</p>
<h5 id="dnew-指令中类引用按需加载">D）new 指令中类引用（按需加载）</h5>
<p>即使常量池里有 class A 的符号引用，也不会解析它，直到执行 new A 时。</p>
<h2 id="初始化">初始化</h2>
<p>初始化是整个类加载过程的最后一个阶段，要注意的是这里的构造器方法并不是开发者写的，而是编译器自动生成的。</p>
<p>执行类的 <clinit> 方法（静态代码块 + 静态变量初始化）。</p>
<h2 id="使用">使用</h2>
<p>方法调用：通过 <code>Method</code>* 或 <code>vtable</code> 入口执行</p>
<p>字段访问：通过 <code>Field offset</code></p>
<p>实例创建：采用分配策略（TLAB → Eden → 老年代）</p>
<h2 id="卸载">卸载</h2>
<p>一个类要被JVM卸载，条件非常苛刻，需要同时满足以下三点：</p>
<ul>
<li><strong>该类所有的实例都已经被回收</strong></li>
<li><strong>加载该类的ClassLoader已经被回收</strong>：类与其加载器是双向绑定的共生关系。一个类由哪个类加载器加载，这个信息是存储在Class对象里的。<strong>要卸载一个类，必须先卸载加载它的类加载器。</strong></li>
<li><strong>类对应的Java.lang.Class对象没有任何地方被引用</strong>：不能在任何地方通过反射（如静态字段、全局变量）、静态变量、JNI等途径引用到这个Class对象。一旦这个Class对象还存在强引用，GC就不会回收它，那么这个类也就不会被卸载。</li>
</ul>
<h1 id="类加载器类型">类加载器类型</h1>
<figure data-type="image" tabindex="3"><img src="https://kanyewestforreal.github.io//post-images/classloader_type.png" alt="classloader_type" loading="lazy"></figure>
<ul>
<li><strong>启动类加载器（Bootstrap Class Loader）</strong>：这是最顶层的类加载器，负责加载Java的核心库（如位于jre/lib/rt.jar中的类），它是用C++编写的，是JVM的一部分。启动类加载器无法被Java程序直接引用，以<code>null</code>指代。</li>
<li><strong>扩展类加载器（Extension Class Loader）</strong>：它是Java语言实现的，继承自ClassLoader类，负责加载Java扩展目录（jre/lib/ext或由系统变量Java.ext.dirs指定的目录）下的jar包和类库。<code>ExtensionClassLoader</code>由<code>BootstrapClassLoader</code>加载，并且父加载器是<code>BootstrapClassLoader</code>。</li>
<li><strong>系统类加载器（System Class Loader）/ 应用程序类加载器（Application Class Loader）</strong>：这也是Java语言实现的，负责加载用户类路径（ClassPath）上的指定类库，是默认使用的类加载器。<code>ApplicationClassLoader</code>的父加载器是<code>ExtensionClassLoader</code>。它可以通过<code>ClassLoader.getSystemClassLoader</code>方法获取到。</li>
<li><strong>自定义类加载器（Custom Class Loader）</strong>：开发者可以根据需求定制类的加载方式，比如从网络加载class文件、数据库、甚至是加密的文件中加载类等。自定义类加载器可以用来扩展Java应用程序的灵活性和安全性，是Java动态性的一个重要体现。</li>
</ul>
<blockquote>
<p>Java 9 引入了模块系统，并且略微更改了上述的类加载器。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 java.base 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。</p>
</blockquote>
<p>上述类加载器之间的父子关系，使用组合关系来实现，代码层上没有通过继承实现。</p>
<pre><code class="language-java">public abstract class ClassLoader {
    private final ClassLoader parent;

    protected ClassLoader(ClassLoader parent) {
        this.parent = parent;
    }
}
</code></pre>
<p>类加载器的父子关系完全是 Java 层 <code>ClassLoader.parent</code> 字段构建出来的树形结构，其作用在于通过 <code>loadClass</code> 的递归调用来实现双亲委派。</p>
<h1 id="双亲委派模型">双亲委派模型</h1>
<p>类加载器之间的层级关系形成了双亲委派模型，其核心思想是<strong>当一个类加载器收到类加载的请求时，首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成</strong>，每一层次的类加载器都是如此，因此所有的加载请求最终都会传送到顶层的启动类加载器中。</p>
<p><strong>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</strong></p>
<p><code>ClassLoader</code> 类有两个关键的方法：</p>
<ul>
<li><code>findClass(String name)</code>：根据类的二进制名称来查找类，默认实现是空方法。</li>
<li><code>loadClass(String name, boolean resolve)</code>：加载指定二进制名称的类 。<code>name</code> 为类的二进制名称，<code>resolve</code> 如果为 true，在加载时调用 <code>resolveClass(Class&lt;?&gt; c)</code> 方法解析该类。</li>
</ul>
<p>如果需要自定义类加载器，同时沿用双亲委派机制，只需重写 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。</p>
<p>但是，如果想破坏双亲委派模型，则需要重写 <code>loadClass()</code> 方法。</p>
<pre><code class="language-java">//ClassLoader#loadClass
protected Class&lt;?&gt; loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        //首先，检查该类是否已经加载过
        Class c = findLoadedClass(name);
        if (c == null) {
            //如果 c 为 null，则说明该类没有被加载过
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    //当父类的加载器不为空，则通过父类的loadClass来加载该类
                    c = parent.loadClass(name, false);
                } else {
                    //当父类的加载器为空，则调用启动类加载器来加载该类
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                //非空父类的类加载器无法找到相应的类，则抛出异常
            }

            if (c == null) {
                //当父类加载器无法加载时，则调用findClass方法来加载该类
                //用户可通过覆写该方法，来自定义类加载器
                long t1 = System.nanoTime();
                c = findClass(name);

                //用于统计类加载器相关的信息
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
   			sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
            sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            //对类进行link操作
            resolveClass(c);
        }
        return c;
    }
}
</code></pre>
<h2 id="双亲委派模型的作用">双亲委派模型的作用</h2>
<ul>
<li><strong>保证类的唯一性、防止核心类被篡改</strong>：确保了所有加载请求都会传递到<code>BootstrapClassLoader</code>，避免了不同类加载器重复加载相同类的情况，保证了Java核心类库的统一性，也保证了类的唯一性，同时还保证了不会加载非信任类路径外的类，防止了用户自定义类覆盖核心类库的可能。</li>
<li><strong>安全隔离</strong>：不同层次的类加载器服务于不同的类加载需求，这种层次化的划分有助于实现沙箱安全机制，保证了各个层级类加载器的职责清晰，也便于维护和扩展。</li>
<li><strong>提高类加载效率，减少冗余扫描</strong>：委派后父级通常已缓存大量常用类，不必每个<code>ClassLoader</code>重复查找扫描。</li>
</ul>
<h2 id="如何破坏双亲委派模型">如何破坏双亲委派模型</h2>
<p>三种方式：</p>
<ol>
<li><strong>重写 <code>loadClass()</code>，不委派给 <code>parent</code></strong></li>
<li><strong>child-first：先 <code>findClass</code>，再 <code>parent.loadClass</code></strong></li>
<li><strong>修改 <code>parent</code>（指向 Bootstrap 或其它 loader）</strong></li>
</ol>
<p>目的是让当前加载器优先加载类。</p>
<h2 id="android中插件化热修复">Android中插件化热修复</h2>
<h3 id="android-的-classloader-结构">Android 的 ClassLoader 结构</h3>
<p>常见的加载器链：</p>
<pre><code class="language-java">BootClassLoader
    ↑
PathClassLoader (加载 APK)
    ↑
DexClassLoader / InMemoryDexClassLoader (可加载补丁dex/插件dex)
</code></pre>
<p><code>PathClassLoader</code>（系统）: 负责加载 APK 中 classes.dex</p>
<p><code>DexClassLoader</code>（第三方）: 可加载任意PATH下的 dex、jar、apk</p>
<h3 id="android-热修复的三大主流方式">Android 热修复的三大主流方式</h3>
<h4 id="tinker主流微信团队">Tinker（主流，微信团队）</h4>
<p>原理：向 <code>PathClassLoader</code> 插入“补丁 dex 的 DexPathList Element”</p>
<p>Android 的类查找流程：</p>
<pre><code class="language-java">PathClassLoader.pathList.dexElements = [x.dex, xx.dex, xxx.dex] //是按顺序查找类
</code></pre>
<p>Tinker 就是在这个数组前面插入补丁 dex。</p>
<p>示例（伪代码）：</p>
<pre><code class="language-java">//反射
Field pathListField = findField(classLoader, &quot;pathList&quot;);
Object pathList = pathListField.get(classLoader);

Field dexElementsField = findField(pathList, &quot;dexElements&quot;);
Object[] oldElements = (Object[]) dexElementsField.get(pathList);

Object[] patchElements = makeDexElements(patchDexFiles);

Object[] newArray = concat(patchElements, oldElements);

dexElementsField.set(pathList, newArray);
</code></pre>
<p><strong>效果：</strong></p>
<ul>
<li>补丁 dex 先被搜索</li>
<li>替换掉原有 class</li>
<li>不改逻辑，不改 loadClass，只改搜索顺序</li>
</ul>
<p>这属于 <strong>class 优先级覆盖</strong>，而不是字节码替换。</p>
<p>优点：</p>
<ul>
<li>最稳定</li>
<li>不破坏 ClassLoader 结构</li>
<li>支持任意类修复</li>
</ul>
<p>缺点：</p>
<ul>
<li>不支持资源修复（需额外方案）</li>
<li>不支持某些极端多 dex 情况</li>
</ul>
<hr>
<h4 id="andfix即时替换方法实现">AndFix（即时替换方法实现）</h4>
<p>直接修改方法指针，替换 <code>ArtMethod</code>。</p>
<p><code>Android ART</code> 虚拟机中，每个方法包含一个结构体：</p>
<pre><code class="language-c++">ArtMethod {
    entry_point_from_quick_compiled_code
}
</code></pre>
<p>AndFix 会：</p>
<ol>
<li>从补丁中提取替代方法</li>
<li>将目标方法的 entrypoint 替换成补丁方法的入口地址</li>
</ol>
<p><strong>这是“方法级别”的替换，不是类加载器层面的。</strong></p>
<p>优点：</p>
<ul>
<li>不需要重启</li>
<li>修复速度快</li>
</ul>
<p>缺点：</p>
<ul>
<li>只能修复方法</li>
<li>不能新增字段</li>
<li>Android 版本变动影响大（兼容性很差）</li>
</ul>
<p>已经比较过时。</p>
<hr>
<h4 id="robust美团">Robust（美团）</h4>
<p>原理：插桩（Instrumentation）+ 代理逻辑</p>
<p>构建阶段对代码插桩，把所有方法入口改为：</p>
<pre><code class="language-java">if (PatchProxy.isSupport(...)) {
    return PatchProxy.accessDispatch(...);
} else {
    // 原代码
}
</code></pre>
<p>当有补丁时，PatchProxy 会进入替代逻辑。</p>
<p>特点：</p>
<ul>
<li><strong>不依赖 ClassLoader 或 Dex 替换</strong></li>
<li><strong>属于 AOP 插桩 + 代理方法分发</strong></li>
</ul>
<p>优点：</p>
<ul>
<li>极稳定</li>
<li>不依赖 ART 实现</li>
<li>热修复兼容性最好</li>
</ul>
<p>缺点：</p>
<ul>
<li>插桩增加 App 体积与开销</li>
<li>语法受限制（某些方法不允许插桩）</li>
</ul>
<h1 id="垃圾回收gc机制">垃圾回收（GC）机制</h1>
<h2 id="什么是垃圾回收">什么是垃圾回收</h2>
<p>垃圾回收是 JVM 自动释放 不再被使用的对象 所占内存 的机制。</p>
<h2 id="垃圾回收作用">垃圾回收作用</h2>
<ul>
<li>自动释放无用对象，避免内存泄漏，减少手动管理带来的错误从而提高效率</li>
<li>避免系统内存耗尽，保证服务持续运行</li>
<li>把碎片化内存整理得更紧凑，使得创建对象更快</li>
</ul>
<h2 id="gc如何触发">GC如何触发</h2>
<ul>
<li><strong>内存不足时</strong>：当JVM检测到堆内存不足，无法为新的对象分配内存时，会自动触发垃圾回收。（堆被分成不同区域，不同区域的内存不足会触发不同类型的GC）</li>
<li><strong>手动请求</strong>：虽然垃圾回收是自动的，开发者可以通过调用 <code>System.gc()</code> 或 <code>Runtime.getRuntime().gc()</code> 建议 JVM 进行垃圾回收。不过这只是一个建议，并不能保证立即执行。</li>
<li><strong>对象数量或内存使用达到阈值</strong>：垃圾收集器内部实现了一些策略，以监控对象的创建和内存使用，达到某个阈值时触发垃圾回收。这些阈值在启动 Java 应用时，可以设置，比如：<code>-Xmx</code>（最大堆大小）、<code>-Xms</code>（初始堆大小）等。</li>
</ul>
<h2 id="判断垃圾算法类型">判断垃圾算法类型</h2>
<p>主要有两种。引用计数法和可达性分析算法。</p>
<h3 id="引用计数">引用计数</h3>
<p>Python之类的使用。</p>
<ul>
<li><strong>原理</strong>：为每个对象分配一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1。当计数器为0时，表示对象不再被任何变量引用，可以被回收。</li>
<li><strong>缺点</strong>：不能解决循环引用的问题，即两个对象相互引用，但不再被其他任何对象引用，这时引用计数器不会为0，导致对象无法被回收。</li>
</ul>
<h3 id="可达性分析算法">可达性分析算法</h3>
<p><strong>这是JVM使用的算法，JVM不使用引用计数判断垃圾，因为无法处理循环引用问题。</strong></p>
<p>从一组称为GC Roots（垃圾收集根）的对象出发，向下追溯它们引用的对象，以及这些对象引用的其他对象，以此类推。如果一个对象到GC Roots没有任何引用链相连（即<strong>从GC Roots到这个对象不可达</strong>），那么这个对象就被认为是不可达的，可以被回收。</p>
<p><strong>GC Roots对象包括：</strong></p>
<p><strong>虚拟机栈（JVM Stack 栈帧中的局部变量表）中引用的对象</strong></p>
<p><strong>方法区中类静态属性引用的对象</strong></p>
<p><strong>本地方法栈中JNI（Java Native Interface）引用的对象</strong></p>
<p><strong>虚拟机内部的引用对象（活跃线程的引用）等。</strong></p>
<h2 id="gc的类型gc的工作区域">GC的类型/GC的工作区域</h2>
<p>根据其工作区域和触发条件的不同，可以将GC分为三种类型：Minor GC（也称为Young GC）、Major GC（有时也称为Old GC）、以及Full GC。</p>
<p>以下是这三种GC的区别和触发场景：</p>
<h3 id="minor-gc-young-gc">Minor GC (Young GC)</h3>
<ul>
<li><strong>作用范围</strong>：只针对年轻代进行回收，包括Eden区和两个Survivor区（S0和S1）。</li>
<li><strong>触发条件</strong>：当Eden区空间不足时，JVM会触发一次Minor GC，将Eden区和一个Survivor区中的存活对象移动到另一个Survivor区或老年代（Old Generation）。</li>
<li><strong>特点</strong>：通常发生得非常频繁，因为年轻代中对象的生命周期较短，回收效率高，暂停时间相对较短。</li>
</ul>
<h3 id="major-gc">Major GC</h3>
<ul>
<li><strong>作用范围</strong>：只针对老年代进行回收。</li>
<li><strong>触发条件</strong>：
<ul>
<li>当老年代空间不足时，触发Major GC。</li>
<li>大量对象在 Survivor 区活得太久，会迅速提前晋升 Old → Old 区变满 → 触发 Major GC。</li>
</ul>
</li>
<li><strong>特点</strong>：相比Minor GC，Major GC发生的频率较低，但每次回收可能需要更长的时间，因为老年代中的对象存活率较高。</li>
</ul>
<h3 id="full-gc">Full GC</h3>
<ul>
<li><strong>作用范围</strong>：对整个堆内存、<strong>元空间</strong>进行回收。</li>
<li><strong>触发条件</strong>：
<ul>
<li>直接调用<code>System.gc()</code>或<code>Runtime.getRuntime().gc()</code>方法时，虽然不能保证立即执行，但JVM会尝试执行Full GC。</li>
<li>大对象无法放入老年代，则会触发Full GC。</li>
<li>年轻代晋升老年代，但是空间不足，不足以容纳存活对象，触发Full GC。</li>
<li>当永久代（Java 8之前的版本）或元空间（Java 8及以后的版本）空间不足时。</li>
</ul>
</li>
<li><strong>特点</strong>：Full GC是最昂贵的操作，<strong>因为它需要停止所有的工作线程（Stop The World）</strong>，遍历整个堆内存来查找和回收不再使用的对象，因此应尽量减少Full GC的触发。</li>
</ul>
<h2 id="gc算法类型">GC算法类型</h2>
<p>按 <em>回收基本策略</em> 分类。</p>
<ul>
<li>
<p><strong>标记-清除算法</strong>（Mark Sweep）：标记-清除算法分为“标记”和“清除”两个阶段，首先通过<strong>可达性分析</strong>，标记出所有需要回收的对象，然后统一回收所有被标记的对象。标记-清除算法<strong>实现简单，不需要移动对象</strong>，但有两个缺陷：<strong>清除阶段较慢、碎片化严重（空洞多）</strong>，容易造成在申请大块内存的时候，因为没有足够的连续空间导致再次 GC。</p>
</li>
<li>
<p><strong>复制算法</strong>（Copying）：为了解决碎片空间的问题，出现了“复制算法”。将堆分为两个区域：From、To<br>
GC 时：</p>
<ol>
<li>扫描 From</li>
<li>将存活对象复制到 To</li>
<li>清空 From</li>
<li>两者角色交换</li>
</ol>
<p>复制算法解决了空间碎片的问题，但是也带来了新的问题，因为每次在申请内存时，都只能使用一半的内存空间，内存利用率严重不足。</p>
</li>
<li>
<p><strong>标记-整理算法</strong>（Mark Compact）：如果<strong>存活对象比较多时，复制算法会执行较多的复制操作</strong>，效率就会下降。而老年代的对象在 GC 之后的存活率就比较高，因此需要新算法。标记-整理算法的“标记”过程与“标记-清除算法”的标记过程一致，但<strong>标记之后不会直接清理</strong>。而是<strong>将所有存活对象都移动</strong>到内存的一端，移动结束后，<strong>直接清理掉一块区域</strong>。</p>
</li>
<li>
<p><strong>分代回收算法</strong>：不算是算法，而是策略。把堆分为年轻代 + 老年代，分别用不同算法。</p>
<ul>
<li>Young 区：对象朝生夕死 → 使用复制算法</li>
<li>Old 区：对象长寿、多对象 → 使用标记整理</li>
</ul>
</li>
</ul>
<h2 id="jvm-gc器类型">JVM GC器类型</h2>
<table>
<thead>
<tr>
<th>收集器</th>
<th>年轻代算法</th>
<th>老年代算法</th>
<th>是否并发</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Serial</strong></td>
<td>复制</td>
<td>标记-整理</td>
<td>否</td>
<td>单线程，简单可靠</td>
</tr>
<tr>
<td><strong>Parallel</strong></td>
<td>复制</td>
<td>标记-整理</td>
<td>否</td>
<td>高吞吐</td>
</tr>
<tr>
<td><strong>CMS<br />(Concurrent Mark-Sweep)</strong></td>
<td>复制</td>
<td><strong>标记-清除</strong></td>
<td>是</td>
<td>低停顿，但有碎片</td>
</tr>
<tr>
<td><strong>G1</strong></td>
<td>复制（Region分区）</td>
<td>标记-整理（Region）</td>
<td>是</td>
<td>面向大堆、低停顿。服务端应用。</td>
</tr>
<tr>
<td><strong>ZGC</strong></td>
<td>Region + 复制</td>
<td>Region + 并发压缩</td>
<td>是（几乎全并发）</td>
<td>子毫秒停顿</td>
</tr>
<tr>
<td><strong>Shenandoah</strong></td>
<td>Region + 复制</td>
<td>Region + 并发压缩</td>
<td>是</td>
<td>极低延迟</td>
</tr>
</tbody>
</table>
<p>现代收集器 G1、ZGC、Shenandoah 基于 Region，同时使用并发标记、复制与压缩技术以降低停顿时间。</p>
<h2 id="art-gc器类型">ART GC器类型</h2>
<p>ART 虽然没有 HotSpot 那样的 Young / Old 物理分区，但仍是 <strong>逻辑分代 GC</strong>：</p>
<ul>
<li>Sticky GC 回 Young 部分</li>
<li>Partial GC 回 Young + 部分 Old</li>
<li>Full GC 回整个堆</li>
</ul>
<p>这是一个<strong>软分代</strong>模型，不是 HotSpot 的硬分代模型。</p>
<p>ART 的 GC 不是一个收集器，而是 <strong>多个收集器协同</strong> 工作：</p>
<h3 id="sticky-mark-sweep粘性标记清除-gc最常触发">Sticky Mark-Sweep（粘性标记清除 GC）（最常触发）</h3>
<p><strong>作用：回收最近死亡的小部分对象（通常是当前 Young 区的小对象）</strong></p>
<p>特征：</p>
<ul>
<li>只扫描“自上次 GC 之后新增或修改过”的对象</li>
<li><strong>非常快</strong>（&lt;1ms）</li>
<li>STW 时间极短</li>
<li>不移动对象（<strong>无 compact</strong>）</li>
</ul>
<p>用途：</p>
<ul>
<li>高频 GC，近年来 Android 优化最重要的一种 GC</li>
</ul>
<p>你可以把它理解为 “增量式 Young GC”。</p>
<hr>
<h3 id="partial-mark-sweep部分标记清除-gc">Partial Mark-Sweep（部分标记清除 GC）</h3>
<p><strong>回收部分堆（通常是 Young + 一部分 Old）</strong></p>
<p>特征：</p>
<ul>
<li>Stop-The-World + 并发</li>
<li>速度比 Full GC 快</li>
<li>不整理碎片</li>
</ul>
<p>用途：</p>
<ul>
<li>Sticky 扫不干净时，会触发它</li>
</ul>
<hr>
<h3 id="full-mark-sweep完整标记清除-gc">Full Mark-Sweep（完整标记清除 GC）</h3>
<p><strong>回收整个堆的所有未引用对象</strong></p>
<p>特征：</p>
<ul>
<li>扫描全堆</li>
<li>STW 较长</li>
<li>不 compact（早期版本）</li>
<li>触发时说明内存压力较高</li>
</ul>
<p>用途：</p>
<ul>
<li>汇总性的 GC，当其他 GC 效果不足时触发</li>
</ul>
<hr>
<h3 id="full-mark-compact完整标记整理-gc">Full Mark-Compact（完整标记整理 GC）</h3>
<p><strong>清除整个堆 + 整理碎片</strong></p>
<p>特征：</p>
<ul>
<li>标记整个堆</li>
<li>移动对象 → 内存连续</li>
<li>停顿较长（但比 Dalvik 时代短很多）</li>
<li>提高长期运行稳定性</li>
</ul>
<p>用途：</p>
<ul>
<li>防止碎片化</li>
<li>ART 运行若干天后，也要偶尔 compact</li>
</ul>
<p>你可以说它类似 HotSpot 的 Mark-Compact。</p>
<h3 id="concurrent-copying-gc">Concurrent Copying GC</h3>
<p>Android 8.0 引入：</p>
<blockquote>
<p><strong>并发复制收集器（Concurrent Copying）</strong><br>
是移动端的“ZGC/Shenandoah 思路”，但更轻。</p>
</blockquote>
<p>特征：</p>
<ul>
<li>有读屏障（read barrier）</li>
<li>对象移动是并发完成的</li>
<li>STW 时间进一步缩短</li>
<li>类似 HotSpot 的 G1/ZGC，但为移动设备优化</li>
</ul>
<h1 id="hotspt-jvm启动流程">HotSpt JVM启动流程</h1>
<h2 id="启动器launcher阶段">启动器（Launcher）阶段</h2>
<p>你执行 <code>java</code> 命令时，其实启动的是<code>C++</code>文件：</p>
<pre><code>/bin/java -&gt; C++ 写的启动器
</code></pre>
<p>它做几件事：</p>
<ul>
<li>解析命令行参数（classpath、-Xmx、-XX… 等）</li>
<li>找到 libjvm.so / jvm.dll 并加载进去</li>
<li>使用 <strong>JNI Invocation API</strong> 创建 JVM</li>
</ul>
<p>调用：</p>
<pre><code>JNI_CreateJavaVM(JavaVM **pvm, JNIEnv **penv, void *args);
</code></pre>
<p>从这一刻起，JVM 虚拟机才真正开始运行。</p>
<hr>
<h2 id="jvm-初始化jni_createjavavm">JVM 初始化（JNI_CreateJavaVM）</h2>
<p>JVM 线程开始执行，它内部依次初始化：</p>
<h3 id="初始化内存模型">初始化内存模型</h3>
<ul>
<li>Java 堆（Heap）</li>
<li>方法区 / 元空间（Metaspace）</li>
<li>CodeCache（JIT 机器码区）</li>
<li>JVM Stack 等</li>
</ul>
<h3 id="初始化-gc-子系统">初始化 GC 子系统</h3>
<p>不同 GC 器（G1、ZGC、Shenandoah）会在此完成内部结构建立。</p>
<h3 id="初始化执行引擎">初始化执行引擎</h3>
<ul>
<li>解释器模板生成（TemplateInterpreter）</li>
<li>C1/C2 / JVMCI JIT 初始化</li>
</ul>
<h3 id="初始化类加载器子系统">初始化类加载器子系统</h3>
<p>加载器顺序：</p>
<ol>
<li><strong>BootstrapClassLoader</strong>（C++ 实现）</li>
<li><strong>PlatformClassLoader</strong>（Java 9+）</li>
<li><strong>AppClassLoader</strong></li>
</ol>
<hr>
<h2 id="加载-jvm-基础类bootstrap-阶段">加载 JVM 基础类（Bootstrap 阶段）</h2>
<p>JVM 必须先加载最基础的类，否则无法运行 Java 世界。</p>
<p>顺序通常如下：</p>
<ul>
<li>加载 <code>java.lang.Object</code>：一切类的起点。</li>
<li>加载 <code>java.lang.String</code>：因为内部很多结构依赖 String（包括类名）。</li>
<li>加载 <code>java.lang.Class</code>：没有 Class 对象，类元数据无从表示。</li>
<li>加载 <code>java.lang.Thread</code>、<code>java.lang.ThreadGroup</code>：JVM 要靠这些表示 Java 层线程，因此启动过程必须提前加载。</li>
</ul>
<blockquote>
<p>加载这些类时都会触发 <strong>静态变量分配、<clinit> 执行、常量解析等</strong>。</p>
</blockquote>
<h2 id="创建主线程main-thread">创建“主线程”（Main Thread）</h2>
<p>虽然底层启动有一个 <strong>Native Thread</strong>，通过其启动JVM，但 JVM 必须创建一个代表它的 Java Thread 对象作为映射。</p>
<p>执行：</p>
<pre><code class="language-java">//fake code
Thread t = new Thread()
</code></pre>
<p>并将其设为：</p>
<ul>
<li>当前线程（main thread）</li>
<li>所属 ThreadGroup（main group）</li>
</ul>
<p>然后这个线程成为执行你<code>main()</code>方法的载体，也就是主线程。</p>
<h2 id="主类main-class的加载">主类（Main-Class）的加载</h2>
<p>现在 JVM 使用 主线程 + <strong>Application ClassLoader</strong> 去加载具有<code>main</code>方法的类。</p>
<p>流程：</p>
<ol>
<li>字节码通过 classpath / modulepath 查找</li>
<li>加载 class 文件</li>
<li>解析类结构（constant pool、methods、fields）</li>
<li>为静态变量分配空间</li>
<li>初始化父类</li>
<li>执行 <code>&lt;clinit&gt;</code>（类初始化：static 语句块 + static 字段赋值）</li>
</ol>
<hr>
<h2 id="解析-main-方法的符号引用">解析 main 方法的符号引用</h2>
<p>JVM 需要找到：</p>
<pre><code>public static void main(String[] args)
</code></pre>
<p>编译器会在常量池中记录方法的 <strong>符号引用</strong>：</p>
<pre><code>&quot;main&quot;, &quot;([Ljava/lang/String;)V&quot;
</code></pre>
<p>JVM 解析后得到：</p>
<ul>
<li>方法所在类</li>
<li>方法描述符</li>
<li>方法入口地址（解释器入口 or JIT 地址）</li>
</ul>
<p>如果找不到，报错：</p>
<pre><code>java.lang.NoSuchMethodError: main
</code></pre>
<hr>
<h2 id="执行-main-方法">执行 main 方法</h2>
<p>启动器调用：</p>
<pre><code>(*env)-&gt;CallStaticVoidMethod(env, mainClass, mainMethodID);
</code></pre>
<p>JVM 开始执行 main 方法的字节码：</p>
<ul>
<li>解释器逐条解释执行指令（iload、invokestatic…）</li>
<li>或触发 JIT，生成机器码</li>
<li>调度 Java 层线程</li>
<li>执行整个程序生命周期</li>
</ul>
<h2 id="总结-2">总结</h2>
<pre><code class="language-java">java 命令启动
  → 解析参数
  → 加载 libjvm
  → 调用 JNI_CreateJavaVM
      → 初始化堆、元空间、GC、解释器、JIT、类加载器
      → Bootstrap 加载 Object/String/Class/Thread…
      → 创建 Java 主线程对象
      → 使用 AppClassLoader 加载主类
          → 类加载 → 验证 → 准备 → 解析 → 初始化
      → 解析 main 方法
      → 调用 main 方法（解释器/JIT 执行）
</code></pre>
<h1 id="参考">参考</h1>
<blockquote>
<p>https://www.xiaolincoding.com/interview/jvm.html</p>
<p>https://javaguide.cn/java/jvm/classloader.html</p>
</blockquote>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B">JVM内存模型</a>
<ul>
<li><a href="#%E6%B3%A8%E6%84%8F">注意</a></li>
<li><a href="#%E5%A0%86heap">堆（Heap）</a>
<ul>
<li><a href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3young-generation">年轻代（Young Generation）</a></li>
<li><a href="#%E8%80%81%E5%B9%B4%E4%BB%A3old-generation">老年代（Old Generation）</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E5%A6%82%E4%BD%95%E6%99%8B%E5%8D%87%E5%88%B0-old-%E5%8C%BA">对象如何晋升到 Old 区？</a></li>
</ul>
</li>
<li><a href="#%E6%96%B9%E6%B3%95%E5%8C%BAmethod-area">方法区（Method Area）</a></li>
<li><a href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88jvm-stack">虚拟机栈（JVM Stack）</a></li>
<li><a href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88native-method-stack">本地方法栈（Native Method Stack）</a></li>
<li><a href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8pc-register">程序计数器（PC Register）</a></li>
<li><a href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98-direct-memory">直接内存 Direct Memory</a></li>
<li><a href="#stack-%E5%92%8C-heap-%E7%9A%84%E5%8C%BA%E5%88%AB">Stack 和 Heap 的区别？</a>
<ul>
<li><a href="#%E5%AD%98%E6%94%BE%E5%86%85%E5%AE%B9%E4%B8%8D%E5%90%8C">存放内容不同</a></li>
<li><a href="#%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C">管理方式不同</a></li>
<li><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8D%E5%90%8C">生命周期不同</a></li>
<li><a href="#%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6%E4%B8%8D%E5%90%8C">访问速度不同</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%80%A7%E4%B8%8D%E5%90%8C">线程共享性不同</a></li>
<li><a href="#%E6%B3%A8%E6%84%8F-2">注意</a></li>
</ul>
</li>
<li><a href="#%E5%BD%93%E7%A8%8B%E5%BA%8F%E4%B8%AD%E9%80%9A%E8%BF%87%E5%AF%B9%E8%B1%A1%E6%88%96%E7%B1%BB%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E6%9F%90%E4%B8%AA%E6%96%B9%E6%B3%95%E6%97%B6jvm%E6%89%A7%E8%A1%8C%E4%BA%86%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">当程序中通过对象或类直接调用某个方法时，JVM执行了哪些操作？</a>
<ul>
<li><a href="#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86">预备知识</a></li>
<li><a href="#invoke%E7%9A%84%E8%A7%A3%E6%9E%90">invoke的解析</a></li>
<li><a href="#%E5%87%86%E5%A4%87%E6%89%A7%E8%A1%8C">准备执行</a></li>
<li><a href="#%E5%BB%BA%E7%AB%8B%E6%A0%88%E5%B8%A7">建立栈帧</a></li>
<li><a href="#%E6%89%A7%E8%A1%8C">执行</a>
<ul>
<li><a href="#%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8Cinterpreter">解释执行（Interpreter）</a></li>
<li><a href="#jit-%E7%BC%96%E8%AF%91%E6%88%90%E6%9C%AC%E5%9C%B0%E6%9C%BA%E5%99%A8%E7%A0%81">JIT 编译成本地机器码</a></li>
</ul>
</li>
<li><a href="#%E7%BB%93%E6%9D%9F-%E9%94%80%E6%AF%81%E6%A0%88%E5%B8%A7">结束、销毁栈帧</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
<li><a href="#string%E7%9A%84%E5%A5%87%E5%A6%99%E6%9C%BA%E5%88%B6">String的奇妙机制</a>
<ul>
<li><a href="#1-%E5%AD%97%E9%9D%A2%E9%87%8F%E6%96%B9%E5%BC%8F">1. 字面量方式</a></li>
<li><a href="#2-new-%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F">2. new 创建方式</a></li>
</ul>
</li>
<li><a href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B">引用类型</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BE%8B%E5%AD%90">内存泄露、内存溢出的原因/例子</a>
<ul>
<li><a href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2">内存泄露</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA">内存溢出</a>
<ul>
<li><a href="#java-heap-space-oom">Java Heap Space OOM</a></li>
<li><a href="#stackoverflowerror">StackOverFlowError</a></li>
<li><a href="#metaspace-oom">MetaSpace OOM</a></li>
<li><a href="#direct-buffer-memory">Direct Buffer Memory</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90">逃逸分析</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%83%E9%80%B8">什么是逃逸？</a></li>
<li><a href="#%E9%80%83%E9%80%B8%E7%B1%BB%E5%9E%8B">逃逸类型</a>
<ul>
<li><a href="#%E5%AE%8C%E5%85%A8%E4%B8%8D%E9%80%83%E9%80%B8noescape">完全不逃逸（NoEscape）</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E9%80%83%E9%80%B8argescape">方法逃逸（ArgEscape）</a></li>
<li><a href="#%E5%85%A8%E5%B1%80%E9%80%83%E9%80%B8globalescape">全局逃逸（GlobalEscape）</a></li>
</ul>
</li>
<li><a href="#%E9%80%83%E9%80%B8%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5">逃逸优化策略</a>
<ul>
<li><a href="#%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2scalar-replacement">标量替换（Scalar Replacement）</a></li>
<li><a href="#%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8Dstack-allocation">栈上分配（Stack Allocation）</a></li>
<li><a href="#%E6%99%AE%E9%80%9A%E5%A0%86%E5%88%86%E9%85%8Dtlab-eden">普通堆分配（TLAB / Eden）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B">创建对象过程</a>
<ul>
<li><a href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A3%80%E6%9F%A5">类加载检查</a></li>
<li><a href="#%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%A0%86-heap">分配对象内存（堆 Heap）</a>
<ul>
<li><a href="#%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E-%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8-tlab">指针碰撞、空闲列表、TLAB</a></li>
<li><a href="#%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E">指针碰撞</a></li>
<li><a href="#%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8">空闲列表</a></li>
<li><a href="#tlab">TLAB</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B">类加载过程</a>
<ul>
<li><a href="#%E5%8A%A0%E8%BD%BD">加载</a></li>
<li><a href="#%E8%BF%9E%E6%8E%A5">连接</a>
<ul>
<li><a href="#%E9%AA%8C%E8%AF%81">验证</a></li>
<li><a href="#%E5%87%86%E5%A4%87">准备</a></li>
<li><a href="#%E8%A7%A3%E6%9E%90">解析</a>
<ul>
<li><a href="#%E8%A7%A3%E6%9E%90%E7%B1%BB%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8">解析类层级结构相关的符号引用</a></li>
<li><a href="#%E8%A7%A3%E6%9E%90%E9%9D%9E%E8%99%9A%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%95%E7%94%A8">解析“非虚方法”的引用</a></li>
<li><a href="#%E8%A7%A3%E6%9E%90%E6%96%B9%E6%B3%95%E5%8F%A5%E6%9F%84">解析方法句柄</a></li>
<li><a href="#%E5%AF%B9%E6%9F%90%E4%BA%9B%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E8%BF%9B%E8%A1%8C%E5%90%88%E6%B3%95%E6%80%A7%E9%AA%8C%E8%AF%81">对某些符号引用进行“合法性验证”</a></li>
<li><a href="#%E5%87%86%E5%A4%87-vtableitable-%E7%9A%84%E7%BB%93%E6%9E%84">准备 vtable/itable 的结构</a></li>
<li><a href="#%E5%93%AA%E4%BA%9B%E8%A7%A3%E6%9E%90%E8%A2%AB%E5%BB%B6%E8%BF%9Flazy-resolution">哪些解析被延迟（Lazy Resolution）？</a>
<ul>
<li><a href="#ainvokevirtual-%E7%9A%84%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90%E8%99%9A%E6%96%B9%E6%B3%95">A）invokevirtual 的方法解析（虚方法）</a></li>
<li><a href="#binvokeinterface-%E7%9A%84%E8%A7%A3%E6%9E%90">B）invokeinterface 的解析</a></li>
<li><a href="#cgetfield-putfield-getstatic-putstatic">C）getfield / putfield / getstatic / putstatic</a></li>
<li><a href="#dnew-%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%B1%BB%E5%BC%95%E7%94%A8%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD">D）new 指令中类引用（按需加载）</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8">使用</a></li>
<li><a href="#%E5%8D%B8%E8%BD%BD">卸载</a></li>
</ul>
</li>
<li><a href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%B1%BB%E5%9E%8B">类加载器类型</a></li>
<li><a href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B">双亲委派模型</a>
<ul>
<li><a href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8">双亲委派模型的作用</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B">如何破坏双亲委派模型</a></li>
<li><a href="#android%E4%B8%AD%E6%8F%92%E4%BB%B6%E5%8C%96%E7%83%AD%E4%BF%AE%E5%A4%8D">Android中插件化热修复</a>
<ul>
<li><a href="#android-%E7%9A%84-classloader-%E7%BB%93%E6%9E%84">Android 的 ClassLoader 结构</a></li>
<li><a href="#android-%E7%83%AD%E4%BF%AE%E5%A4%8D%E7%9A%84%E4%B8%89%E5%A4%A7%E4%B8%BB%E6%B5%81%E6%96%B9%E5%BC%8F">Android 热修复的三大主流方式</a>
<ul>
<li><a href="#tinker%E4%B8%BB%E6%B5%81%E5%BE%AE%E4%BF%A1%E5%9B%A2%E9%98%9F">Tinker（主流，微信团队）</a></li>
<li><a href="#andfix%E5%8D%B3%E6%97%B6%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0">AndFix（即时替换方法实现）</a></li>
<li><a href="#robust%E7%BE%8E%E5%9B%A2">Robust（美团）</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6gc%E6%9C%BA%E5%88%B6">垃圾回收（GC）机制</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">什么是垃圾回收</a></li>
<li><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BD%9C%E7%94%A8">垃圾回收作用</a></li>
<li><a href="#gc%E5%A6%82%E4%BD%95%E8%A7%A6%E5%8F%91">GC如何触发</a></li>
<li><a href="#%E5%88%A4%E6%96%AD%E5%9E%83%E5%9C%BE%E7%AE%97%E6%B3%95%E7%B1%BB%E5%9E%8B">判断垃圾算法类型</a>
<ul>
<li><a href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0">引用计数</a></li>
<li><a href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95">可达性分析算法</a></li>
</ul>
</li>
<li><a href="#gc%E7%9A%84%E7%B1%BB%E5%9E%8Bgc%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%9F%9F">GC的类型/GC的工作区域</a>
<ul>
<li><a href="#minor-gc-young-gc">Minor GC (Young GC)</a></li>
<li><a href="#major-gc">Major GC</a></li>
<li><a href="#full-gc">Full GC</a></li>
</ul>
</li>
<li><a href="#gc%E7%AE%97%E6%B3%95%E7%B1%BB%E5%9E%8B">GC算法类型</a></li>
<li><a href="#jvm-gc%E5%99%A8%E7%B1%BB%E5%9E%8B">JVM GC器类型</a></li>
<li><a href="#art-gc%E5%99%A8%E7%B1%BB%E5%9E%8B">ART GC器类型</a>
<ul>
<li><a href="#sticky-mark-sweep%E7%B2%98%E6%80%A7%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4-gc%E6%9C%80%E5%B8%B8%E8%A7%A6%E5%8F%91">Sticky Mark-Sweep（粘性标记清除 GC）（最常触发）</a></li>
<li><a href="#partial-mark-sweep%E9%83%A8%E5%88%86%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4-gc">Partial Mark-Sweep（部分标记清除 GC）</a></li>
<li><a href="#full-mark-sweep%E5%AE%8C%E6%95%B4%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4-gc">Full Mark-Sweep（完整标记清除 GC）</a></li>
<li><a href="#full-mark-compact%E5%AE%8C%E6%95%B4%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86-gc">Full Mark-Compact（完整标记整理 GC）</a></li>
<li><a href="#concurrent-copying-gc">Concurrent Copying GC</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#hotspt-jvm%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">HotSpt JVM启动流程</a>
<ul>
<li><a href="#%E5%90%AF%E5%8A%A8%E5%99%A8launcher%E9%98%B6%E6%AE%B5">启动器（Launcher）阶段</a></li>
<li><a href="#jvm-%E5%88%9D%E5%A7%8B%E5%8C%96jni_createjavavm">JVM 初始化（JNI_CreateJavaVM）</a>
<ul>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B">初始化内存模型</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96-gc-%E5%AD%90%E7%B3%BB%E7%BB%9F">初始化 GC 子系统</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E">初始化执行引擎</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AD%90%E7%B3%BB%E7%BB%9F">初始化类加载器子系统</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A0%E8%BD%BD-jvm-%E5%9F%BA%E7%A1%80%E7%B1%BBbootstrap-%E9%98%B6%E6%AE%B5">加载 JVM 基础类（Bootstrap 阶段）</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%BB%E7%BA%BF%E7%A8%8Bmain-thread">创建“主线程”（Main Thread）</a></li>
<li><a href="#%E4%B8%BB%E7%B1%BBmain-class%E7%9A%84%E5%8A%A0%E8%BD%BD">主类（Main-Class）的加载</a></li>
<li><a href="#%E8%A7%A3%E6%9E%90-main-%E6%96%B9%E6%B3%95%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8">解析 main 方法的符号引用</a></li>
<li><a href="#%E6%89%A7%E8%A1%8C-main-%E6%96%B9%E6%B3%95">执行 main 方法</a></li>
<li><a href="#%E6%80%BB%E7%BB%93-2">总结</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://kanyewestforreal.github.io/post/java-multithreading-p4/">
              <h3 class="post-title">
                Java多线程笔记（4）
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  This blog is just for me to record the questions, which in my developing.
  <div class="footer-right">
    <a class="rss" href="https://kanyewestforreal.github.io//atom.xml" target="_blank">
      <i class="ri-rss-line"></i> RSS
    </a>
    <span id="busuanzi_container_site_pv" style="margin-top: 8px;">
      本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
  </div>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>

      </div>
    </div>

    <script>
      // hljs.initHighlightingOnLoad()

      // let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // // This should probably be throttled.
      // // Especially because it triggers during smooth scrolling.
      // // https://lodash.com/docs/4.17.10#throttle
      // // You could do like...
      // // window.addEventListener("scroll", () => {
      // //    _.throttle(doThatStuff, 100);
      // // });
      // // Only not doing it here to keep this Pen dependency-free.

      // window.addEventListener("scroll", event => {
      //   let fromTop = window.scrollY;

      //   mainNavLinks.forEach((link, index) => {
      //     let section = document.getElementById(decodeURI(link.hash).substring(1));
      //     let nextSection = null
      //     if (mainNavLinks[index + 1]) {
      //       nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      //     }
      //     if (section.offsetTop <= fromTop) {
      //       if (nextSection) {
      //         if (nextSection.offsetTop > fromTop) {
      //           link.classList.add("current");
      //         } else {
      //           link.classList.remove("current");    
      //         }
      //       } else {
      //         link.classList.add("current");
      //       }
      //     } else {
      //       link.classList.remove("current");
      //     }
      //   });
      // });

    </script>
  </body>
</html>
